{"ast":null,"code":"/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\"use strict\";\n\nvar DOMProperty = require(\"./DOMProperty\");\n\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar containsNode = require(\"./containsNode\");\n\nvar deprecated = require(\"./deprecated\");\n\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\n\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\n\nvar invariant = require(\"./invariant\");\n\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\n\nvar warning = require(\"./warning\");\n\nvar createElement = ReactLegacyElement.wrapCreateElement(ReactElement.createElement);\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n/** Mapping from reactRootID to React component instance. */\n\nvar instancesByReactRootID = {};\n/** Mapping from reactRootID to `container` nodes. */\n\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n} // Used to store breadth-first search state in findComponentRoot.\n\n\nvar findComponentRootReusableArray = [];\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\n\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\n\n\nfunction getID(node) {\n  var id = internalGetID(node);\n\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n\n      if (cached !== node) {\n        \"production\" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id));\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\n\n\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\n\n\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\n\n\nfunction isValid(node, id) {\n  if (node) {\n    \"production\" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id);\n    var container = ReactMount.findReactContainerForID(id);\n\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\n\n\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\n\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\n\n\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n/**\n * Mounting is the process of initializing a React component by creatings its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\n\n\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextComponent, container, callback) {\n    var nextProps = nextComponent.props;\n    ReactMount.scrollMonitor(container, function () {\n      prevComponent.replaceProps(nextProps, callback);\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: ReactPerf.measure('ReactMount', '_renderNewRootComponent', function (nextComponent, container, shouldReuseMarkup) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var componentInstance = instantiateReactComponent(nextComponent, null);\n\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    componentInstance.mountComponentIntoNode(reactRootID, container, shouldReuseMarkup);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  }),\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'renderComponent(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : ReactLegacyElement.isValidFactory(nextElement) ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : // Check if it quacks like a element\n    typeof nextElement.props !== \"undefined\" ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(ReactElement.isValidElement(nextElement));\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback);\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup);\n\n    callback && callback.call(component);\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function (constructor, props, container) {\n    var element = createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function (constructor, props, id) {\n    var domNode = document.getElementById(id);\n    \"production\" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of \"%s\" but it is not present on the page.', id) : invariant(domNode);\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n\n    if (!component) {\n      return false;\n    }\n\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function (instance, container) {\n    instance.unmountComponent();\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    } // http://jsperf.com/emptying-a-node\n\n\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n\n      if (rootElement && rootElement.parentNode !== container) {\n        \"production\" !== process.env.NODE_ENV ? invariant( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID);\n        var containerChild = container.firstChild;\n\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          console.warn('ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode);\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function (node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    var current = node;\n\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n\n      current = current.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n    \"production\" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false);\n  },\n\n  /**\n   * React ID utilities.\n   */\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  purgeID: purgeID\n}; // Deprecations (remove for 0.13)\n\nReactMount.renderComponent = deprecated('ReactMount', 'renderComponent', 'render', this, ReactMount.render);\nmodule.exports = ReactMount;","map":{"version":3,"sources":["C:/Users/Aleksander/Documents/Uczelnia/SPS/REACT/callendar/node_modules/react-ajax/node_modules/react/lib/ReactMount.js"],"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactElement","ReactLegacyElement","ReactInstanceHandles","ReactPerf","containsNode","deprecated","getReactRootElementInContainer","instantiateReactComponent","invariant","shouldUpdateReactComponent","warning","createElement","wrapCreateElement","SEPARATOR","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","getReactRootID","container","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextComponent","callback","nextProps","props","replaceProps","_registerComponent","nodeType","ensureScrollValueMonitoring","reactRootID","registerContainer","_renderNewRootComponent","measure","shouldReuseMarkup","current","componentInstance","mountComponentIntoNode","render","nextElement","isValidElement","isValidFactory","prevElement","_currentElement","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","isRenderedByReact","component","call","constructAndRenderComponent","constructor","element","constructAndRenderComponentByID","domNode","document","getElementById","getReactRootIDFromNodeID","createReactRootID","unmountComponentFromNode","instance","unmountComponent","documentElement","lastChild","removeChild","parentNode","containerChild","firstChild","console","warn","reactRoot","findComponentRoot","charAt","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","length","child","targetChild","childID","isAncestorIDOf","push","nextSibling","renderComponent","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n\"use strict\";\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactLegacyElement = require(\"./ReactLegacyElement\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar containsNode = require(\"./containsNode\");\nvar deprecated = require(\"./deprecated\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\n\nvar createElement = ReactLegacyElement.wrapCreateElement(\n  ReactElement.createElement\n);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounting is the process of initializing a React component by creatings its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextComponent,\n      container,\n      callback) {\n    var nextProps = nextComponent.props;\n    ReactMount.scrollMonitor(container, function() {\n      prevComponent.replaceProps(nextProps, callback);\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        container.nodeType === ELEMENT_NODE_TYPE ||\n        container.nodeType === DOC_NODE_TYPE\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      container.nodeType === ELEMENT_NODE_TYPE ||\n      container.nodeType === DOC_NODE_TYPE\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: ReactPerf.measure(\n    'ReactMount',\n    '_renderNewRootComponent',\n    function(\n        nextComponent,\n        container,\n        shouldReuseMarkup) {\n      // Various parts of our code (such as ReactCompositeComponent's\n      // _renderValidatedComponent) assume that calls to render aren't nested;\n      // verify that that's the case.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        ReactCurrentOwner.current == null,\n        '_renderNewRootComponent(): Render methods should be a pure function ' +\n        'of props and state; triggering nested component updates from ' +\n        'render is not allowed. If necessary, trigger nested updates in ' +\n        'componentDidUpdate.'\n      ) : null);\n\n      var componentInstance = instantiateReactComponent(nextComponent, null);\n      var reactRootID = ReactMount._registerComponent(\n        componentInstance,\n        container\n      );\n      componentInstance.mountComponentIntoNode(\n        reactRootID,\n        container,\n        shouldReuseMarkup\n      );\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        // Record the root element in case it later gets transplanted.\n        rootElementsByReactRootID[reactRootID] =\n          getReactRootElementInContainer(container);\n      }\n\n      return componentInstance;\n    }\n  ),\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'renderComponent(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        ReactLegacyElement.isValidFactory(nextElement) ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like a element\n        typeof nextElement.props !== \"undefined\" ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        );\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    );\n    callback && callback.call(component);\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    instance.unmountComponent();\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          console.warn(\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          );\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  purgeID: purgeID\n};\n\n// Deprecations (remove for 0.13)\nReactMount.renderComponent = deprecated(\n  'ReactMount',\n  'renderComponent',\n  'render',\n  this,\n  ReactMount.render\n);\n\nmodule.exports = ReactMount;\n"]},"metadata":{},"sourceType":"script"}